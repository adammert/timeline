<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline Präsentation</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* Presentation-specific styles */
    body {
      margin: 0;
      padding: 50px 70px;
      overflow-y: auto;
      background-color: var(--background-color);
    }

    .presentation-container {
      max-width: 1300px;
      margin: 0 auto;
    }

    .timeline {
      max-width: 100%;
    }

    /* Enhanced fonts for presentation */
    .timeline-title {
      font-size: 2.8em;
      margin-bottom: 60px;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    .timeline-item {
      padding-left: 80px;
      margin-bottom: 50px;
    }

    .timeline-item::before {
      left: 18px;
      width: 28px;
      height: 28px;
      border-width: 4px;
      box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.3), 0 3px 8px rgba(0, 0, 0, 0.15);
    }

    .timeline::before {
      left: 32px;
      width: 4px;
      opacity: 0.8;
    }

    .timeline-date {
      font-size: 1.1em;
      margin-bottom: 14px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .timeline-content {
      font-size: 1.15em;
      padding: 26px 32px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.06);
    }

    .timeline-content:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12), 0 3px 6px rgba(0, 0, 0, 0.08);
      border-color: rgba(0, 123, 255, 0.5);
    }

    .timeline-content h1 {
      font-size: 1.65em;
      margin-bottom: 0.65em;
      font-weight: 700;
      letter-spacing: -0.3px;
    }

    .timeline-content h2 {
      font-size: 1.45em;
      margin-bottom: 0.65em;
      letter-spacing: -0.2px;
    }

    .timeline-content h3 {
      font-size: 1.25em;
      margin-bottom: 0.65em;
      letter-spacing: -0.1px;
    }

    .timeline-content p {
      margin-bottom: 0.85em;
      line-height: 1.75;
    }

    .duration-bar {
      left: 36px;
      width: 3px;
    }

    .duration-end-marker {
      left: 18px;
      width: 28px;
      height: 28px;
      border-width: 4px;
    }

    .duration-label {
      font-size: 0.9em;
      padding: 5px 12px;
      border-radius: 6px;
      font-weight: 500;
    }

    /* Swimlane enhancements for presentation */
    .timeline.is-swimlanes .timeline-lane-header {
      font-size: 1.2em;
      padding: 18px 15px 25px;
      letter-spacing: 0.5px;
    }

    .timeline.is-swimlanes .timeline-title {
      margin-bottom: 60px;
    }

    .timeline.is-swimlanes .timeline-item {
      padding-left: 70px;
    }

    .timeline.is-swimlanes .timeline-item::before {
      left: 10px;
    }

    /* Loading indicator */
    .loading-message {
      text-align: center;
      padding: 100px 20px;
      color: var(--secondary-color);
      font-size: 1.5em;
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      top: 15px;
      right: 15px;
      padding: 8px 15px;
      background-color: var(--panel-background);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      font-size: 0.9em;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #4caf50;
      animation: pulse 2s infinite;
    }

    .status-indicator.disconnected {
      background-color: #f44336;
      animation: none;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }
    }

    /* Responsive adjustments */
    @media (max-width: 1200px) {
      body {
        padding: 40px 60px;
      }

      .timeline-title {
        font-size: 2.2em;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 30px 40px;
      }

      .timeline-title {
        font-size: 1.8em;
      }

      .timeline-item {
        padding-left: 60px;
      }

      .timeline-content {
        font-size: 1em;
        padding: 18px 20px;
      }
    }
  </style>
</head>

<body>
  <div class="connection-status">
    <div class="status-indicator" id="statusIndicator"></div>
    <span id="statusText">Verbunden</span>
  </div>

  <div class="presentation-container">
    <div id="timelineOutput" class="timeline">
      <div class="loading-message">
        Warte auf Daten vom Hauptfenster...
      </div>
    </div>
  </div>

  <script src="js/config.js"></script>
  <script src="js/parser.js"></script>
  <script src="js/images.js"></script>
  <script>
    // Presentation Window Script
    (function () {
      'use strict';

      const timelineOutput = document.getElementById('timelineOutput');
      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      let channel = null;
      let lastUpdate = Date.now();
      let connectionCheckInterval = null;
      let currentTheme = 'light';
      let activeFilters = new Set(['critical', 'warning', 'success', 'meeting', 'work', 'none']);
      let currentSearchQuery = '';

      /**
       * Initialize BroadcastChannel
       */
      function initChannel() {
        try {
          channel = new BroadcastChannel('timeline_presentation');

          channel.onmessage = (event) => {
            lastUpdate = Date.now();
            updateConnectionStatus(true);

            if (event.data.type === 'update') {
              renderTimeline(event.data.markdown);
            } else if (event.data.type === 'ping') {
              // Respond to ping
              channel.postMessage({ type: 'pong' });
            } else if (event.data.type === 'theme') {
              // Apply theme
              applyTheme(event.data.theme);
            } else if (event.data.type === 'filters') {
              // Update filters
              activeFilters = new Set(event.data.filters);
              currentSearchQuery = event.data.searchQuery || '';
              applySearchAndFilter();
            } else if (event.data.type === 'init') {
              // Initial data with theme and filters
              applyTheme(event.data.theme);
              if (event.data.filters) {
                activeFilters = new Set(event.data.filters);
              }
              if (event.data.searchQuery) {
                currentSearchQuery = event.data.searchQuery;
              }
              renderTimeline(event.data.markdown);
            }
          };

          // Request initial data
          channel.postMessage({ type: 'request_data' });

          // Check connection status periodically
          connectionCheckInterval = setInterval(() => {
            const timeSinceLastUpdate = Date.now() - lastUpdate;
            if (timeSinceLastUpdate > 5000) {
              updateConnectionStatus(false);
            }
          }, 2000);

        } catch (e) {
          console.error('BroadcastChannel nicht unterstützt:', e);
          timelineOutput.innerHTML = '<div class="loading-message">Fehler: BroadcastChannel API nicht unterstützt.</div>';
        }
      }

      /**
       * Apply search and filter to timeline
       */
      function applySearchAndFilter() {
        const timelineItems = timelineOutput.querySelectorAll('.timeline-item');
        let visibleCount = 0;

        timelineItems.forEach((item) => {
          const content = item.querySelector('.timeline-content');
          if (!content) return;

          // Determine event class
          let eventClass = 'none';
          const validClasses = ['critical', 'warning', 'success', 'meeting', 'work'];
          validClasses.forEach((cls) => {
            if (content.classList.contains(`is-${cls}`)) {
              eventClass = cls;
            }
          });

          // Check filter
          const passesFilter = activeFilters.has(eventClass);

          // Check search
          let passesSearch = true;
          if (currentSearchQuery) {
            const textContent = item.textContent.toLowerCase();
            passesSearch = textContent.includes(currentSearchQuery.toLowerCase());
          }

          // Apply visibility
          if (passesFilter && passesSearch) {
            item.classList.remove('filtered-out');
            visibleCount++;
          } else {
            item.classList.add('filtered-out');
          }
        });

        // Show/hide no results message
        const existingMessage = timelineOutput.querySelector('.no-results-message');
        if (existingMessage) {
          existingMessage.remove();
        }

        if (visibleCount === 0 && timelineItems.length > 0) {
          const message = document.createElement('div');
          message.className = 'no-results-message';
          message.textContent = currentSearchQuery
            ? `Keine Ereignisse gefunden für "${currentSearchQuery}"`
            : 'Keine Ereignisse entsprechen den ausgewählten Filtern';
          message.style.textAlign = 'center';
          message.style.padding = '60px 20px';
          message.style.color = 'var(--secondary-color)';
          message.style.fontSize = '1.3em';
          timelineOutput.appendChild(message);
        }
      }

      /**
       * Apply theme to presentation window
       */
      function applyTheme(theme) {
        if (!theme) return;
        currentTheme = theme;
        document.documentElement.setAttribute('data-theme', theme);
      }

      /**
       * Update connection status indicator
       */
      function updateConnectionStatus(connected) {
        if (connected) {
          statusIndicator.classList.remove('disconnected');
          statusText.textContent = 'Verbunden';
        } else {
          statusIndicator.classList.add('disconnected');
          statusText.textContent = 'Getrennt';
        }
      }

      /**
       * Render timeline from markdown
       */
      async function renderTimeline(markdown) {
        if (!markdown || !markdown.trim()) {
          timelineOutput.innerHTML = '<div class="loading-message">Keine Daten vorhanden.</div>';
          return;
        }

        const parsed = TimelineApp.Parser.extractTitleFromMarkdown(markdown);
        const currentTitle = parsed.title;
        const bodyText = parsed.body || '';
        const bodyOffset = markdown.indexOf(bodyText);

        if (!bodyText.trim()) {
          timelineOutput.innerHTML = '<div class="loading-message">Bitte gib Daten im Hauptfenster ein.</div>';
          return;
        }

        const events = TimelineApp.Parser.parseEvents(bodyText, bodyOffset);

        if (events.length === 0) {
          timelineOutput.innerHTML = '<div class="loading-message">Keine gültigen Ereignisse gefunden.</div>';
          return;
        }

        events.sort((a, b) => a.date - b.date);
        timelineOutput.innerHTML = '';

        // Add title
        if (currentTitle) {
          const titleEl = document.createElement('h1');
          titleEl.classList.add('timeline-title');
          titleEl.textContent = currentTitle;
          timelineOutput.appendChild(titleEl);
        }

        // Render events
        events.forEach((event, index) => {
          renderEvent(event, index, events);
        });

        // Add today marker
        addTodayMarker(events);

        // Add duration bars and replace images after DOM is ready
        setTimeout(async () => {
          addDurationBars(events);
          // Replace image references
          if (TimelineApp.Images) {
            await TimelineApp.Images.replaceImageReferences(timelineOutput);
          }
          // Apply filters after rendering
          applySearchAndFilter();
        }, 50);
      }

      /**
       * Helper: return localized weekday name
       */
      function getWeekdayLabel(date) {
        if (!(date instanceof Date) || isNaN(date.getTime())) {
          return '';
        }

        try {
          return date.toLocaleDateString('de-DE', { weekday: 'long' });
        } catch (error) {
          console.warn('Failed to format weekday', error);
          return '';
        }
      }

      /**
       * Render single event
       */
      function renderEvent(event, index, allEvents) {
        const itemDiv = document.createElement('div');
        itemDiv.classList.add('timeline-item');
        if (event.endDate) itemDiv.classList.add('has-duration');

        const dateDiv = document.createElement('div');
        dateDiv.classList.add('timeline-date');

        if (event.date.getTime() === 0) {
          dateDiv.textContent = 'Fehlerhaftes Event';
          dateDiv.style.color = 'red';
        } else {
          const weekdayLabel = getWeekdayLabel(event.date);

          if (event.displayDateString) {
            dateDiv.textContent = weekdayLabel
              ? event.displayDateString + ' (' + weekdayLabel + ')'
              : event.displayDateString;
          } else {
            let formattedDate = event.date.toLocaleDateString('de-DE', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit'
            });
            if (event.explicitTimeProvided) {
              formattedDate += ' ' + event.date.toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit'
              });
            }
            if (weekdayLabel) {
              formattedDate += ' (' + weekdayLabel + ')';
            }
            dateDiv.textContent = formattedDate;
          }
        }

        if (event.endDate && event.date.getTime() !== 0) {
          const durationSpan = document.createElement('span');
          durationSpan.className = 'duration-label';
          durationSpan.textContent = TimelineApp.Parser.calculateDuration(
            event.date,
            event.endDate
          );
          dateDiv.appendChild(durationSpan);
        }

        const contentDiv = document.createElement('div');
        contentDiv.classList.add('timeline-content');
        if (event.eventClass) contentDiv.classList.add(event.eventClass);

        // Create temporary container for parsing
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = marked.parse(event.content || 'Kein Inhalt.');

        // Find and replace all images with images/ prefix BEFORE adding to DOM
        const images = tempDiv.querySelectorAll('img');
        images.forEach(img => {
          const src = img.getAttribute('src');
          if (src && src.startsWith('images/')) {
            const filename = src.replace('images/', '');
            // Set placeholder and data attribute
            img.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAAAAACw=');
            img.setAttribute('data-filename', filename);
            img.style.display = 'none';
          }
        });

        // Now move the processed content to the actual contentDiv
        while (tempDiv.firstChild) {
          contentDiv.appendChild(tempDiv.firstChild);
        }

        itemDiv.appendChild(dateDiv);
        itemDiv.appendChild(contentDiv);
        itemDiv.dataset.index = index;
        timelineOutput.appendChild(itemDiv);
      }

      /**
       * Add duration bars
       */
      function addDurationBars(events) {
        const allItems = timelineOutput.querySelectorAll('.timeline-item');

        events.forEach((event, index) => {
          if (!event.endDate || event.date >= event.endDate) return;

          const startItem = allItems[index];
          if (!startItem) return;

          let endItem = null;
          let endPositionTop = -1;

          for (let i = index + 1; i < events.length; i++) {
            if (events[i].date >= event.endDate) {
              endItem = allItems[i];
              break;
            }
          }

          const startTop = startItem.offsetTop;
          if (endItem) {
            endPositionTop = endItem.offsetTop;
          } else {
            const lastItem = allItems[allItems.length - 1];
            if (lastItem) {
              endPositionTop = lastItem.offsetTop + lastItem.offsetHeight;
            }
          }

          if (endPositionTop > startTop) {
            const height = endPositionTop - startTop;
            if (height > 20) {
              const durationBar = document.createElement('div');
              durationBar.classList.add('duration-bar');
              durationBar.style.height = height - 2 + 'px';
              startItem.appendChild(durationBar);

              const endMarker = document.createElement('div');
              endMarker.classList.add('duration-end-marker');
              endMarker.style.top = height + 'px';
              startItem.appendChild(endMarker);
            }
          }
        });
      }

      /**
       * Add today marker
       */
      function addTodayMarker(events) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const validEvents = events.filter(
          e => e.date.getTime() !== new Date(0).getTime()
        );
        if (validEvents.length === 0) return;

        let insertIndex = -1;

        for (let i = 0; i < validEvents.length; i++) {
          const eventDate = new Date(validEvents[i].date);
          eventDate.setHours(0, 0, 0, 0);

          if (eventDate >= today) {
            insertIndex = i;
            break;
          }
        }

        if (insertIndex === -1) {
          insertIndex = validEvents.length;
        }

        const timelineItems = timelineOutput.querySelectorAll('.timeline-item');

        const todayMarker = document.createElement('div');
        todayMarker.classList.add('current-date-marker');
        todayMarker.style.display = 'block';

        const todayLabel = document.createElement('span');
        todayLabel.classList.add('current-date-marker-label');
        todayLabel.textContent = 'Heute';
        todayMarker.appendChild(todayLabel);

        let targetNode = null;
        if (insertIndex < timelineItems.length) {
          targetNode = timelineItems[insertIndex];
        }

        if (targetNode) {
          timelineOutput.insertBefore(todayMarker, targetNode);
        } else {
          timelineOutput.appendChild(todayMarker);
        }
      }

      // Handle window close
      window.addEventListener('beforeunload', () => {
        if (channel) {
          channel.postMessage({ type: 'presentation_closed' });
          channel.close();
        }
        if (connectionCheckInterval) {
          clearInterval(connectionCheckInterval);
        }
      });

      // Initialize
      async function initPresentation() {
        await TimelineApp.Images.init();
        initChannel();
      }

      initPresentation();
    })();
  </script>
</body>

</html>