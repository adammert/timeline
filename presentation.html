<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline Präsentation</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* Presentation-specific styles */
    body {
      margin: 0;
      padding: 40px 60px;
      overflow-y: auto;
      background-color: var(--panel-background);
    }
    
    .presentation-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .timeline {
      max-width: 100%;
    }
    
    /* Larger fonts for presentation */
    .timeline-title {
      font-size: 2.5em;
      margin-bottom: 40px;
    }
    
    .timeline-item {
      padding-left: 80px;
      margin-bottom: 40px;
    }
    
    .timeline-item::before {
      left: 20px;
      width: 32px;
      height: 32px;
      border-width: 5px;
    }
    
    .timeline::before {
      left: 35px;
      width: 6px;
    }
    
    .timeline-date {
      font-size: 1.2em;
      margin-bottom: 12px;
    }
    
    .timeline-content {
      font-size: 1.1em;
      padding: 20px 25px;
      border-radius: 8px;
    }
    
    .timeline-content h1 {
      font-size: 1.8em;
    }
    
    .timeline-content h2 {
      font-size: 1.5em;
    }
    
    .timeline-content h3 {
      font-size: 1.3em;
    }
    
    .duration-bar {
      left: 36px;
    }
    
    .duration-end-marker {
      left: 20px;
      width: 32px;
      height: 32px;
      border-width: 4px;
    }
    
    /* Loading indicator */
    .loading-message {
      text-align: center;
      padding: 100px 20px;
      color: var(--secondary-color);
      font-size: 1.5em;
    }
    
    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 15px;
      background-color: var(--panel-background);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      font-size: 0.9em;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    
    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #4caf50;
      animation: pulse 2s infinite;
    }
    
    .status-indicator.disconnected {
      background-color: #f44336;
      animation: none;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="connection-status">
    <div class="status-indicator" id="statusIndicator"></div>
    <span id="statusText">Verbunden</span>
  </div>
  
  <div class="presentation-container">
    <div id="timelineOutput" class="timeline">
      <div class="loading-message">
        Warte auf Daten vom Hauptfenster...
      </div>
    </div>
  </div>

  <script src="js/config.js"></script>
  <script src="js/parser.js"></script>
  <script src="js/images.js"></script>
  <script>
    // Presentation Window Script
    (function() {
      'use strict';
      
      const timelineOutput = document.getElementById('timelineOutput');
      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      let channel = null;
      let lastUpdate = Date.now();
      let connectionCheckInterval = null;
      let currentTheme = 'light';
      let activeFilters = new Set(['critical', 'warning', 'success', 'meeting', 'work', 'none']);
      let currentSearchQuery = '';
      
      /**
       * Initialize BroadcastChannel
       */
      function initChannel() {
        try {
          channel = new BroadcastChannel('timeline_presentation');
          
          channel.onmessage = (event) => {
            lastUpdate = Date.now();
            updateConnectionStatus(true);
            
            if (event.data.type === 'update') {
              renderTimeline(event.data.markdown);
            } else if (event.data.type === 'ping') {
              // Respond to ping
              channel.postMessage({ type: 'pong' });
            } else if (event.data.type === 'theme') {
              // Apply theme
              applyTheme(event.data.theme);
            } else if (event.data.type === 'filters') {
              // Update filters
              activeFilters = new Set(event.data.filters);
              currentSearchQuery = event.data.searchQuery || '';
              applySearchAndFilter();
            } else if (event.data.type === 'init') {
              // Initial data with theme and filters
              applyTheme(event.data.theme);
              if (event.data.filters) {
                activeFilters = new Set(event.data.filters);
              }
              if (event.data.searchQuery) {
                currentSearchQuery = event.data.searchQuery;
              }
              renderTimeline(event.data.markdown);
            }
          };
          
          // Request initial data
          channel.postMessage({ type: 'request_data' });
          
          // Check connection status periodically
          connectionCheckInterval = setInterval(() => {
            const timeSinceLastUpdate = Date.now() - lastUpdate;
            if (timeSinceLastUpdate > 5000) {
              updateConnectionStatus(false);
            }
          }, 2000);
          
        } catch (e) {
          console.error('BroadcastChannel nicht unterstützt:', e);
          timelineOutput.innerHTML = '<div class="loading-message">Fehler: BroadcastChannel API nicht unterstützt.</div>';
        }
      }
      
      /**
       * Apply search and filter to timeline
       */
      function applySearchAndFilter() {
        const timelineItems = timelineOutput.querySelectorAll('.timeline-item');
        let visibleCount = 0;
        
        timelineItems.forEach((item) => {
          const content = item.querySelector('.timeline-content');
          if (!content) return;
          
          // Determine event class
          let eventClass = 'none';
          const validClasses = ['critical', 'warning', 'success', 'meeting', 'work'];
          validClasses.forEach((cls) => {
            if (content.classList.contains(`is-${cls}`)) {
              eventClass = cls;
            }
          });
          
          // Check filter
          const passesFilter = activeFilters.has(eventClass);
          
          // Check search
          let passesSearch = true;
          if (currentSearchQuery) {
            const textContent = item.textContent.toLowerCase();
            passesSearch = textContent.includes(currentSearchQuery.toLowerCase());
          }
          
          // Apply visibility
          if (passesFilter && passesSearch) {
            item.classList.remove('filtered-out');
            visibleCount++;
          } else {
            item.classList.add('filtered-out');
          }
        });
        
        // Show/hide no results message
        const existingMessage = timelineOutput.querySelector('.no-results-message');
        if (existingMessage) {
          existingMessage.remove();
        }
        
        if (visibleCount === 0 && timelineItems.length > 0) {
          const message = document.createElement('div');
          message.className = 'no-results-message';
          message.textContent = currentSearchQuery
            ? `Keine Ereignisse gefunden für "${currentSearchQuery}"`
            : 'Keine Ereignisse entsprechen den ausgewählten Filtern';
          message.style.textAlign = 'center';
          message.style.padding = '60px 20px';
          message.style.color = 'var(--secondary-color)';
          message.style.fontSize = '1.3em';
          timelineOutput.appendChild(message);
        }
      }
      
      /**
       * Apply theme to presentation window
       */
      function applyTheme(theme) {
        if (!theme) return;
        currentTheme = theme;
        document.documentElement.setAttribute('data-theme', theme);
      }
      
      /**
       * Update connection status indicator
       */
      function updateConnectionStatus(connected) {
        if (connected) {
          statusIndicator.classList.remove('disconnected');
          statusText.textContent = 'Verbunden';
        } else {
          statusIndicator.classList.add('disconnected');
          statusText.textContent = 'Getrennt';
        }
      }
      
      /**
       * Render timeline from markdown
       */
      async function renderTimeline(markdown) {
        if (!markdown || !markdown.trim()) {
          timelineOutput.innerHTML = '<div class="loading-message">Keine Daten vorhanden.</div>';
          return;
        }
        
        const parsed = TimelineApp.Parser.extractTitleFromMarkdown(markdown);
        const currentTitle = parsed.title;
        const bodyText = parsed.body || '';
        const bodyOffset = markdown.indexOf(bodyText);
        
        if (!bodyText.trim()) {
          timelineOutput.innerHTML = '<div class="loading-message">Bitte gib Daten im Hauptfenster ein.</div>';
          return;
        }
        
        const events = TimelineApp.Parser.parseEvents(bodyText, bodyOffset);
        
        if (events.length === 0) {
          timelineOutput.innerHTML = '<div class="loading-message">Keine gültigen Ereignisse gefunden.</div>';
          return;
        }
        
        events.sort((a, b) => a.date - b.date);
        timelineOutput.innerHTML = '';
        
        // Add title
        if (currentTitle) {
          const titleEl = document.createElement('h1');
          titleEl.classList.add('timeline-title');
          titleEl.textContent = currentTitle;
          timelineOutput.appendChild(titleEl);
        }
        
        // Render events
        events.forEach((event, index) => {
          renderEvent(event, index, events);
        });
        
        // Add today marker
        addTodayMarker(events);
        
        // Add duration bars and replace images after DOM is ready
        setTimeout(async () => {
          addDurationBars(events);
          // Replace image references
          if (TimelineApp.Images) {
            await TimelineApp.Images.replaceImageReferences(timelineOutput);
          }
          // Apply filters after rendering
          applySearchAndFilter();
        }, 50);
      }
      
      /**
       * Render single event
       */
      function renderEvent(event, index, allEvents) {
        const itemDiv = document.createElement('div');
        itemDiv.classList.add('timeline-item');
        if (event.endDate) itemDiv.classList.add('has-duration');
        
        const dateDiv = document.createElement('div');
        dateDiv.classList.add('timeline-date');
        
        if (event.date.getTime() === 0) {
          dateDiv.textContent = 'Fehlerhaftes Event';
          dateDiv.style.color = 'red';
        } else if (event.displayDateString) {
          dateDiv.textContent = event.displayDateString;
        } else {
          let formattedDate = event.date.toLocaleDateString('de-DE', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
          });
          if (event.explicitTimeProvided) {
            formattedDate += ' ' + event.date.toLocaleTimeString('de-DE', {
              hour: '2-digit',
              minute: '2-digit'
            });
          }
          dateDiv.textContent = formattedDate;
        }
        
        if (event.endDate && event.date.getTime() !== 0) {
          const durationSpan = document.createElement('span');
          durationSpan.className = 'duration-label';
          durationSpan.textContent = TimelineApp.Parser.calculateDuration(
            event.date,
            event.endDate
          );
          dateDiv.appendChild(durationSpan);
        }
        
        const contentDiv = document.createElement('div');
        contentDiv.classList.add('timeline-content');
        if (event.eventClass) contentDiv.classList.add(event.eventClass);
        
        // Create temporary container for parsing
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = marked.parse(event.content || 'Kein Inhalt.');
        
        // Find and replace all images with images/ prefix BEFORE adding to DOM
        const images = tempDiv.querySelectorAll('img');
        images.forEach(img => {
          const src = img.getAttribute('src');
          if (src && src.startsWith('images/')) {
            const filename = src.replace('images/', '');
            // Set placeholder and data attribute
            img.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAAAAACw=');
            img.setAttribute('data-filename', filename);
            img.style.display = 'none';
          }
        });
        
        // Now move the processed content to the actual contentDiv
        while (tempDiv.firstChild) {
          contentDiv.appendChild(tempDiv.firstChild);
        }
        
        itemDiv.appendChild(dateDiv);
        itemDiv.appendChild(contentDiv);
        itemDiv.dataset.index = index;
        timelineOutput.appendChild(itemDiv);
      }
      
      /**
       * Add duration bars
       */
      function addDurationBars(events) {
        const allItems = timelineOutput.querySelectorAll('.timeline-item');
        
        events.forEach((event, index) => {
          if (!event.endDate || event.date >= event.endDate) return;
          
          const startItem = allItems[index];
          if (!startItem) return;
          
          let endItem = null;
          let endPositionTop = -1;
          
          for (let i = index + 1; i < events.length; i++) {
            if (events[i].date >= event.endDate) {
              endItem = allItems[i];
              break;
            }
          }
          
          const startTop = startItem.offsetTop;
          if (endItem) {
            endPositionTop = endItem.offsetTop;
          } else {
            const lastItem = allItems[allItems.length - 1];
            if (lastItem) {
              endPositionTop = lastItem.offsetTop + lastItem.offsetHeight;
            }
          }
          
          if (endPositionTop > startTop) {
            const height = endPositionTop - startTop;
            if (height > 20) {
              const durationBar = document.createElement('div');
              durationBar.classList.add('duration-bar');
              durationBar.style.height = height - 2 + 'px';
              startItem.appendChild(durationBar);
              
              const endMarker = document.createElement('div');
              endMarker.classList.add('duration-end-marker');
              endMarker.style.top = height + 'px';
              startItem.appendChild(endMarker);
            }
          }
        });
      }
      
      /**
       * Add today marker
       */
      function addTodayMarker(events) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const validEvents = events.filter(
          e => e.date.getTime() !== new Date(0).getTime()
        );
        if (validEvents.length === 0) return;
        
        let insertIndex = -1;
        
        for (let i = 0; i < validEvents.length; i++) {
          const eventDate = new Date(validEvents[i].date);
          eventDate.setHours(0, 0, 0, 0);
          
          if (eventDate >= today) {
            insertIndex = i;
            break;
          }
        }
        
        if (insertIndex === -1) {
          insertIndex = validEvents.length;
        }
        
        const timelineItems = timelineOutput.querySelectorAll('.timeline-item');
        
        const todayMarker = document.createElement('div');
        todayMarker.classList.add('current-date-marker');
        todayMarker.style.display = 'block';
        
        const todayLabel = document.createElement('span');
        todayLabel.classList.add('current-date-marker-label');
        todayLabel.textContent = 'Heute';
        todayMarker.appendChild(todayLabel);
        
        let targetNode = null;
        if (insertIndex < timelineItems.length) {
          targetNode = timelineItems[insertIndex];
        }
        
        if (targetNode) {
          timelineOutput.insertBefore(todayMarker, targetNode);
        } else {
          timelineOutput.appendChild(todayMarker);
        }
      }
      
      // Handle window close
      window.addEventListener('beforeunload', () => {
        if (channel) {
          channel.postMessage({ type: 'presentation_closed' });
          channel.close();
        }
        if (connectionCheckInterval) {
          clearInterval(connectionCheckInterval);
        }
      });
      
      // Initialize
      async function initPresentation() {
        await TimelineApp.Images.init();
        initChannel();
      }
      
      initPresentation();
    })();
  </script>
</body>
</html>
